<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>武仙-北冕座长城的技术专栏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="武仙-北冕座长城的技术专栏">
<meta property="og:url" content="http://tomahawk2018.github.io/index.html">
<meta property="og:site_name" content="武仙-北冕座长城的技术专栏">
<meta property="og:locale">
<meta property="article:author" content="武仙北冕座长城">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="武仙-北冕座长城的技术专栏" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">武仙-北冕座长城的技术专栏</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">行到水穷处，坐看云起时</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Tomahawk2018.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-欢迎文章" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/07/%E6%AC%A2%E8%BF%8E%E6%96%87%E7%AB%A0/" class="article-date">
  <time class="dt-published" datetime="2025-02-07T08:47:18.000Z" itemprop="datePublished">2025-02-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%AC%A2%E8%BF%8E/">欢迎</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/07/%E6%AC%A2%E8%BF%8E%E6%96%87%E7%AB%A0/">欢迎文章</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="欢迎来到"><a href="#欢迎来到" class="headerlink" title="欢迎来到"></a>欢迎来到</h1><p>亲爱的朋友们：</p>
<p>欢迎来到 北冕长城！非常开心能在这里与大家分享各种有趣、有价值的内容。在开始愉快的阅读之旅前，有些重要的事情想和大家交代一下。</p>
<h2 id="一、文章搬运说明"><a href="#一、文章搬运说明" class="headerlink" title="一、文章搬运说明"></a>一、文章搬运说明</h2><p>为了给大家带来更丰富多元的知识和见解，本博客会有部分文章进行搬运。这些搬运的文章均来自网络上优秀的创作者和平台，并且在每篇搬运文章中，我都会明确注明文章的原始出处和作者信息，以确保对原作者的尊重和版权的维护。</p>
<p>搬运的目的纯粹是为了知识的传播和分享，希望能让更多朋友接触到这些精彩内容。如果原作者对文章的搬运存在任何疑问或要求，请随时通过 [博主联系方式，如邮箱、留言板链接等] 与我联系，我会立即按照您的要求进行处理，包括但不限于删除文章、补充更多版权信息等。</p>
<h2 id="二、免责条款"><a href="#二、免责条款" class="headerlink" title="二、免责条款"></a>二、免责条款</h2><ol>
<li><strong>内容准确性</strong>：虽然我在搬运和整理文章时，会尽最大努力确保内容的准确性和可靠性，但由于网络信息的多样性和复杂性，无法对所有文章的内容真实性、完整性和时效性做出绝对保证。文章中的观点仅代表原作者个人，不一定反映本博主的立场。如果您依据这些文章中的信息做出任何决策或行为，由此产生的一切后果需由您自行承担，本博客不承担任何责任。</li>
<li><strong>版权问题</strong>：尽管我在搬运文章时遵循注明出处等原则，但仍有可能存在版权纠纷的风险。若因搬运文章引发任何版权相关的法律问题，一切责任和法律后果由原作者和文章来源平台承担，与本博客无关。</li>
<li><strong>外部链接</strong>：本博客中可能会包含一些指向其他网站的外部链接，这些链接仅为方便读者获取更多信息而提供。我无法对这些外部网站的内容、隐私政策和安全性负责。当您点击这些链接时，您将离开本博客，进入其他网站，请注意阅读相关网站的使用条款和隐私政策。</li>
</ol>
<p>本博客致力于为大家营造一个良好的知识交流和分享环境，希望大家在这里能有所收获。如果您对博客的内容、规则等有任何意见或建议，欢迎随时与我交流。再次感谢大家的支持与关注！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tomahawk2018.github.io/2025/02/07/%E6%AC%A2%E8%BF%8E%E6%96%87%E7%AB%A0/" data-id="cm6uj3e0j00039gvu7d7pcjtj" data-title="欢迎文章" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AC%A2%E8%BF%8E/" rel="tag">欢迎</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-主页-子堆栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/07/%E4%B8%BB%E9%A1%B5-%E5%AD%90%E5%A0%86%E6%A0%88/" class="article-date">
  <time class="dt-published" datetime="2025-02-07T08:44:29.000Z" itemprop="datePublished">2025-02-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B5%84%E6%96%99%E5%BA%93/">资料库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/07/%E4%B8%BB%E9%A1%B5-%E5%AD%90%E5%A0%86%E6%A0%88/">主页|子堆栈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>🔗 原文链接： <a target="_blank" rel="noopener" href="https://substack.com/home/post/p-155252583">https://substack.com/home/post/p-15...</a></p>
</blockquote>
<p>API代表<strong>应用程序编程接口</strong>。</p>
<p>从本质上讲，API是一堆接受<strong>输入</strong>并提供可预测输出<strong>的代码。</strong>   </p>
<p><img src="https://iq7yw19tqs.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2I2MzQzMzIzNWRjN2RmYjU1ZDA3MDdlODYwZDNmMzhfbXFlS29rcG9zUE5YRTdsRUwxRGttM0dIcGRwSXpJMThfVG9rZW46RjlzcWJkRUlDb05LWkR4c3RmWmNIRnNzbkNoXzE3Mzg5MTc4OTY6MTczODkyMTQ5Nl9WNA" alt="img"></p>
<p>可以将API视为一个<strong>中间人</strong>，它使应用程序能够进行交互，<strong>而无需直接访问彼此的代码或数据库</strong>。</p>
<p>您今天使用的几乎每一项数字服务（社交媒体、电子商务、网上银行、叫车应用程序）都是一堆协同工作的 API。</p>
<p><strong>例子：</strong></p>
<ul>
<li><strong>天气API</strong>-如果您提供城市名称作为输入（<code>&quot;纽约&quot;</code>），API将返回<strong>当前温度，湿度和天气状况</strong>。</li>
<li><strong>Uber 乘车 API——</strong> 如果您提供 <strong>上车地址和目的地地址</strong> ，API 会找到 <strong>最近的可用司机</strong> 并计算预计车费。</li>
<li><strong>Python的</strong><code>sorted（）</code> <strong>API</strong>-如果您提供一个数字列表（<code>[5,3,8,1]</code>），API将返回<strong>排序后的列表</strong>（<code>[1,3,5,8]</code>）。</li>
</ul>
<p>当工程师构建API时，他们会明确定义<strong>API接受哪些输入</strong>以及<strong>产生哪些输出</strong>，从而确保不同应用程序之间的行为一致。</p>
<p>API遵循简单的<strong>请求-响应</strong>模型：</p>
<p><img src="https://iq7yw19tqs.feishu.cn/space/api/box/stream/download/asynccode/?code=ODg0ZGZmMTg0N2I4ZjgxNDNiZjMzOWM4NmIyMDI3NGJfeUkxclJHVWs1cVZGR2N0ZExPQ0ZpSGpPOFdXMDlSY0pfVG9rZW46Sks4eGJ5aWkxb200N3V4Mk1pRGNjUll2bjBVXzE3Mzg5MTc4OTY6MTczODkyMTQ5Nl9WNA" alt="img"></p>
<ul>
<li>客户端（例如Web应用程序或移动应用程序）向API发出请求。</li>
<li>API（托管在 API 服务器上）处理请求、与必要的数据库或服务交互并准备响应。</li>
<li>API以结构化格式（通常是JSON或XML）将响应发送回客户端。</li>
</ul>
<p>每个API都需要<strong>特定类型的输入</strong>，传递不正确的数据可能会导致错误。</p>
<p>如果您尝试将您的姓名作为输入放入Google地图API中，效果就不会很好。</p>
<p>一些API还<strong>要求特定格式的输入</strong>。</p>
<p>示例：<strong>货币兑换API</strong>可能需要输入<code>&quot;USD_TO_EUR&quot;</code>而不是<code>&quot;美元兑欧元&quot;</code>。</p>
<p>API通常会在处理输入之前<strong>验证输入以确保其正确无误，这有助于保持准确性和安全性</strong>。 </p>
<p>正如API需要<strong>特定的输入一样</strong>，它们也会返回<strong>结构良好的输出</strong>。</p>
<p>例如，<strong>谷歌地图API</strong>始终<strong>以相同的格式返回坐标</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;latitude&quot;: 40.6892,</span><br><span class="line">  &quot;longitude&quot;: -74.0445</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 API 找不到该位置，它会提供错误响应并解释原因。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &quot;Invalid address format&quot;,</span><br><span class="line">  &quot;code&quot;: 400</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您每天使用的应用程序（无论是<strong>Gmail、Instagram、Uber还是Spotify</strong>）本质上<strong>都是API的集合，顶部带有精致的用户界面（UI）</strong>。</p>
<p>大多数应用程序遵循 <strong>前端&#x2F;后端架构</strong> ，其中：</p>
<ul>
<li>后端由处理数据处理、业务逻辑和与数据库通信的<strong>API组成</strong>。 </li>
<li>前端是一个与这些API交互的<strong>图形用户界面（GUI）</strong>，使应用程序变得用户友好且可访问，<strong>而无需用户编写代码</strong>。</li>
</ul>
<p><img src="https://iq7yw19tqs.feishu.cn/space/api/box/stream/download/asynccode/?code=MmNmMTU2NzdmNDNmYmIzM2JhODM5NDFiMGVjNzBlOTJfOVJSaGM5QTVIWUR4bER3d2t2RDJNc25tV21RbVVKeFBfVG9rZW46SjI4TGIwbHFjb2hNbUN4QUs1Z2NxYWtwbkJjXzE3Mzg5MTc4OTY6MTczODkyMTQ5Nl9WNA" alt="img"></p>
<p>让我们用一个现实世界的例子来解释这一点：<strong>优步</strong>。</p>
<p>在Uber应用程序以流畅、用户友好的体验出现之前，该公司首先构建了<strong>支持叫车服务的核心API：</strong></p>
<ul>
<li>寻找附近的司机</li>
<li>计算票价和路线</li>
<li>处理付款</li>
<li>实时追踪</li>
<li>匹配乘客和司机</li>
</ul>
<p>这些 API 在 Uber 的服务器上运行，构成了 <strong>后端基础设施</strong> 。每次您请求乘车、追踪司机或付款时，这些后端 API 都会处理请求。</p>
<p><strong>后端工程师</strong>负责优化这些API，改进乘车匹配算法，确保交易安全，并确保数百万用户的流畅体验。</p>
<p>后端API处理<strong>所有复杂逻辑</strong>，但它们<strong>只能通过代码工作</strong>-这对于日常用户来说并不实用.这就是为什么公司在这些API之上构建<strong>前端（用户界面），让用户能够直观地与系统交互</strong>。 </p>
<p><strong>示例：<strong>当您输入上车和目的地地址时，前端会发送API请求以</strong>查找附近的司机</strong>并显示可用的车辆。</p>
<p>一旦行程完成，前端可能会调用处理支付API来显示收据。</p>
<p><a target="_blank" rel="noopener" href="https://blog.algomaster.io/p/whats-an-api?utm_source=substack&utm_medium=email&utm_content=share&action=share&token=eyJ1c2VyX2lkIjozMTIyMDM5NTksInBvc3RfaWQiOjE1NTI1MjU4MywiaWF0IjoxNzM3NjE4MTc3LCJleHAiOjE3NDAyMTAxNzcsImlzcyI6InB1Yi0yMjAyMjY4Iiwic3ViIjoicG9zdC1yZWFjdGlvbiJ9.nqW4T2A1n3fXe7VAPlGpZb1U5mHXebVIxhffSlUg8Ss">分享</a></p>
<p>API有不同的形式，取决于<strong>谁可以访问它们</strong>，<strong>如何使用它们</strong>以及<strong>它们的用途</strong>。</p>
<p>开放API（也称为<strong>公共API</strong>）可供外部开发人员以极少的限制访问。</p>
<p>公司提供这些API是为了鼓励<strong>第三方开发人员</strong>集成他们的服务并在其基础上构建新的应用程序。</p>
<p>通常，当您使用<strong>油管应用时</strong>，它会进行<strong>内部API调用</strong>来获取您的视频源，搜索内容或发表评论.但是，油管还提供了一个<strong>公共API，允许开发人员在应用之外</strong>访问其中一些功能。 </p>
<p>例如，<strong>油管搜索API</strong>允许开发人员根据关键字获取视频结果.如果您使用作为<code>&quot;机器学习教程&quot;</code>搜索词向API发送请求，它将返回一个结构化响应（JSON格式），其中包含相关视频的列表，包括<strong>标题，描述，缩略图和视频链接</strong>。</p>
<p>这非常有用，因为它使开发人员能够在 YouTube 上构建自定义应用程序。</p>
<p><strong>API</strong>又称为<strong>私有API，专为组织内部使用而</strong>设计。与开放API不同，外部开发人员无法访问这些API。 </p>
<p>以<strong>亚马逊</strong>为例.当您下订单时，您可能会认为只有一个系统处理您的请求.实际上，<strong>多个内部API</strong>（订单处理，库存，付款，物流等）在后台协同工作，以高效性地完成您的订单。</p>
<p>每个API都<strong>独立运行</strong>，但它们通过明确定义的协议进行通信，以确保流程顺畅、高效。</p>
<p>内部API允许公司将其应用程序分解为<strong>更小，更易于管理的服务</strong>，从而更易于扩展.开发人员可以在不同的项目中<strong>重复使用内部API，从而减少重复</strong>并加快开发速度。 </p>
<p>我们讨论的前两种类型的API（<strong>开放API和内部API</strong>）具有实用性，可用于**实际用例，**例如获取天气数据或预订行程。</p>
<p>但是还有另一类API是开发人员日常使用的：<strong>代码接口</strong>（也称为<strong>库API</strong>或<strong>编程API</strong>）。</p>
<p>这些 API 并不连接不同的应用程序；而是在编程语言或框架内提供预定义的函数，以简化开发。</p>
<p>**示例：**Python的内置列表API</p>
<p>处理列表时，Python提供了一组<strong>内置函数（方法）来操作数据</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numbers = [5, 3, 8, 1, 4]</span><br><span class="line">numbers.sort()  # API call to sort the list</span><br><span class="line"></span><br><span class="line">fruits = [&quot;apple&quot;, &quot;banana&quot;]</span><br><span class="line">fruits.append(&quot;orange&quot;)  # API call to add an element</span><br><span class="line"></span><br><span class="line">fruits.pop()  # API call to remove the last element</span><br></pre></td></tr></table></figure>

<p> <code>sort（）</code>开发人员可以使用Python中的或而不必从头编写排序算法<code>sorted（）</code>。</p>
<p>代码API不仅限于内置的编程语言函数.以AI&#x2F;ML库**TensorFlow为例.它提供了一个高级API，**用于训练机器学习模型，而无需从头开始实现复杂的数学运算。 </p>
<p>例如，使用TensorFlow的API创建<strong>神经网络</strong>非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">model = tf.keras.Sequential([tf.keras.layers.Dense(64, activation=&quot;relu&quot;)])</span><br></pre></td></tr></table></figure>

<p>编程 API 抽象了复杂性，以便开发人员可以专注于构建解决方案，而不是重新发明轮子。</p>
<p>API使用不同的<strong>协议和架构进行通信</strong>，这些协议和架构定义了如何发送请求，如何格式化响应以及如何在系统之间交换数据。</p>
<p>REST是目前使用最广泛的API通信方法，它<strong>轻量、无状态、可扩展</strong>，非常适合Web服务和移动应用程序。</p>
<p>RESTAPI遵循一组设计原则并使用<strong>HTTP方法</strong>（GET， POST，PUT，DELETE）执行操作。</p>
<p>RESTAPI基于<strong>资源，每个资源都通过URL（端点）<strong>访问。API遵循</strong>客户端-服务器模型</strong>，这意味着客户端发送请求，服务器处理该请求并发送响应。   </p>
<p><strong>检索书籍列表（GET 请求）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://api.bookstore.com/books</span><br></pre></td></tr></table></figure>

<p><strong>响应（JSON）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;Clean Code&quot;, &quot;author&quot;: &quot;Robert C. Martin&quot; &#125;,</span><br><span class="line">  &#123; &quot;id&quot;: 2, &quot;title&quot;: &quot;The Pragmatic Programmer&quot;, &quot;author&quot;: &quot;Andrew Hunt&quot; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>SOAP是一种较旧的API通信方法，<strong>依赖于基于XML的消息传递</strong>。</p>
<p>与轻量级的REST不同，SOAP更加结构化且更安全，非常适合银行、医疗保健和企业应用程序。</p>
<p> <strong>SOAP消息使用XML格式</strong>发送，需要<strong>WSDL（Web服务描述语言）文件</strong>，该文件定义了API的可用功能和请求结构。</p>
<p><strong>请求：</strong> 获取账户余额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:bank=&quot;http://bank.example.com/&quot;&gt;</span><br><span class="line">   &lt;soapenv:Header/&gt;</span><br><span class="line">   &lt;soapenv:Body&gt;</span><br><span class="line">      &lt;bank:GetAccountBalance&gt;</span><br><span class="line">         &lt;bank:accountNumber&gt;123456&lt;/bank:accountNumber&gt;</span><br><span class="line">      &lt;/bank:GetAccountBalance&gt;</span><br><span class="line">   &lt;/soapenv:Body&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p><strong>回复：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;</span><br><span class="line">   &lt;soapenv:Body&gt;</span><br><span class="line">      &lt;bank:GetAccountBalanceResponse&gt;</span><br><span class="line">         &lt;bank:balance&gt;5000.00&lt;/bank:balance&gt;</span><br><span class="line">      &lt;/bank:GetAccountBalanceResponse&gt;</span><br><span class="line">   &lt;/soapenv:Body&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p>GraphQL是REST的替代方案，它<strong>允许客户端精确请求所需的数据</strong>，从而使其对现代应用程序来说更加高效，与需要多次API调用才能获取相关数据的REST不同，GraphQL可以<strong>在单个请求中获取所有必要的数据</strong>。</p>
<p>GraphQL没有预定义端点，而是公开单个<strong>API端点</strong>，客户端发送查询来请求特定字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  user(id: 123) &#123;</span><br><span class="line">    name</span><br><span class="line">    email</span><br><span class="line">    posts &#123;</span><br><span class="line">      title</span><br><span class="line">      likes</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回复：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;user&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Alice&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;alice@example.com&quot;,</span><br><span class="line">      &quot;posts&quot;: [</span><br><span class="line">        &#123; &quot;title&quot;: &quot;Hello World&quot;, &quot;likes&quot;: 100 &#125;,</span><br><span class="line">        &#123; &quot;title&quot;: &quot;GraphQL is Amazing!&quot;, &quot;likes&quot;: 200 &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gRPC（谷歌远程过程调用）是一种<strong>高性能API通信方式</strong>，它使用**协议缓冲区（Protobuf）**代替JSON或XML，从而更快，更高效。</p>
<p>gRPC使用<strong>二进制数据格式</strong>而不是基于文本的格式，从而减少了有效负载大小，并且支持<strong>双向流</strong>，这意味着客户端和服务器可以同时发送数据。</p>
<p>使用API乍一看可能很复杂，但它遵循简单的<strong>请求-响应</strong>模式。</p>
<p>以下是有关如何逐步<strong>查找、访问和与API交互</strong>的指南：</p>
<p>在使用API之前，您需要<strong>确定适合</strong>您需求的API。API可用于不同的服务，例如天气数据、金融、社交媒体等。</p>
<p><strong>公共 API 目录：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://rapidapi.com/">RapidAPI–</a>一个提供免费和付费选项的API市场。</li>
<li><a target="_blank" rel="noopener" href="https://www.postman.com/explore">邮递员API网络</a>-公共API的集合。</li>
<li><a target="_blank" rel="noopener" href="https://apilist.fun/">API</a>-有趣的免费公共API列表。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/public-apis/public-apis">GitHub的公共API列表</a>-开源API集合。</li>
</ul>
<p><strong>官方 API 文档：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/">谷歌API</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.x.com/">接口</a></li>
<li><a target="_blank" rel="noopener" href="https://openweathermap.org/api">OpenWeatherAPI</a></li>
</ul>
<p>API文档解释了<strong>如何使用API、可用端点、身份验证和响应格式</strong>。</p>
<p>*<em>示例：</em>***<a target="_blank" rel="noopener" href="https://openweathermap.org/api/one-call-3">OpenWeatherMap</a>**API</p>
<p>OpenWeatherMap API 允许用户获取实时天气数据。以下是其主要组件的细分：</p>
<p><strong>API 网址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.openweathermap.org/data/3.0/weather?q=city_name&amp;appid=YOUR_API_KEY</span><br></pre></td></tr></table></figure>

<p><strong>必需参数：</strong></p>
<ul>
<li><code>Q</code>：城市名称（例如<code>伦敦</code>）</li>
<li><code>appid</code>：API密钥（访问所需）</li>
</ul>
<p>大多数API都<strong>需要身份验证</strong>，以防止未经授权的访问并管理使用限制。</p>
<ul>
<li>**API密钥-**API服务提供的唯一密钥</li>
<li>**OAuth 2.0-**通过Google、Github等安全登录。</li>
<li>**JWT（JSONWeb Token）：**基于Token的身份验证</li>
<li>**基本身份验证：**用户名+密码（Base64编码）</li>
</ul>
<p><strong>示例：获取API密钥（OpenWeatherAPI）</strong></p>
<ul>
<li>在 <a target="_blank" rel="noopener" href="https://home.openweathermap.org/users/sign_up">https://home.openweathermap.org/users/sign_up</a> 注册。</li>
<li>转到<strong>API密钥</strong>。</li>
<li>在请求中使用 API 密钥：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://api.openweathermap.org/data/2.5/weather?q=London&amp;appid=YOUR_API_KEY</span><br></pre></td></tr></table></figure>

<p>在编写代码之前，<strong>先测试API</strong>以查看其响应情况。</p>
<ul>
<li>下载并安装**<a target="_blank" rel="noopener" href="https://www.postman.com/">Postman</a>**。</li>
<li>点击**”新请求”**，输入API端点URL（<code>https://api.openweathermap.org/data/3.0/weather?q=London&amp;appid=YOUR_API_KEY</code>）。</li>
<li>选择<strong>GET</strong>作为HTTP方法。</li>
<li>单击**”发送”并查看JSON格式**的响应。</li>
</ul>
<p>您还可以使用cURL直接<strong>从命令行</strong>测试**<a target="_blank" rel="noopener" href="https://curl.se/">API</a>**。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &quot;https://api.openweathermap.org/data/3.0/weather?q=New+York&amp;appid=YOUR_API_KEY&quot;</span><br></pre></td></tr></table></figure>

<p>现在您已经测试了API，是时候将<strong>其集成到您的应用程序中了</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;https://api.openweathermap.org/data/3.0/weather?q=New York&amp;appid=YOUR_API_KEY&quot;</span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line">if response.status_code == 200:</span><br><span class="line">    data = response.json()</span><br><span class="line">    print(f&quot;Temperature: &#123;data[&#x27;main&#x27;][&#x27;temp&#x27;]&#125;°C&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;Error:&quot;, response.status_code)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>request. get（url）</code>-发送API请求。</li>
<li><code>response.json()</code> – 将响应转换为 JSON。</li>
<li><code>if response.status_code==200</code>-检查请求是否成功。</li>
</ul>
<p>API<strong>并不总是能返回完美的响应</strong>。您应该处理：</p>
<ul>
<li><strong>输入无效</strong> （例如，错误的城市名称）。</li>
<li><strong>身份验证错误</strong>（例如，API密钥过期）。</li>
<li><strong>速率限制</strong> （例如超出请求限制）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if response.status_code == 200:</span><br><span class="line">    data = response.json()</span><br><span class="line">    print(f&quot;Weather: &#123;data[&#x27;weather&#x27;][0][&#x27;description&#x27;]&#125;&quot;)</span><br><span class="line">elif response.status_code == 401:</span><br><span class="line">    print(&quot;Error: Invalid API key&quot;)</span><br><span class="line">elif response.status_code == 404:</span><br><span class="line">    print(&quot;Error: City not found&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;Unexpected error: &#123;response.status_code&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>一旦从API获取数据，就可以<strong>在网络或移动应用程序中动态显示它</strong>。</p>
<p>**示例：**您可以使用OpenWeatherMapAPI构建天气仪表板。</p>
<ul>
<li>从 API 获取实时天气数据。</li>
<li>解析并提取相关细节（温度、湿度、条件）。</li>
<li>以用户友好的格式显示天气报告。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tomahawk2018.github.io/2025/02/07/%E4%B8%BB%E9%A1%B5-%E5%AD%90%E5%A0%86%E6%A0%88/" data-id="cm6uj3e0d00009gvu8udj0kjh" data-title="主页|子堆栈" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-设计像WhatsApp这样的聊天应用程序-系统设计访谈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/07/%E8%AE%BE%E8%AE%A1%E5%83%8FWhatsApp%E8%BF%99%E6%A0%B7%E7%9A%84%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AE%BF%E8%B0%88/" class="article-date">
  <time class="dt-published" datetime="2025-02-07T08:40:48.000Z" itemprop="datePublished">2025-02-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B5%84%E6%96%99%E5%BA%93/">资料库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/07/%E8%AE%BE%E8%AE%A1%E5%83%8FWhatsApp%E8%BF%99%E6%A0%B7%E7%9A%84%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AE%BF%E8%B0%88/">设计像WhatsApp这样的聊天应用程序-系统设计访谈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>🔗 原文链接： <a target="_blank" rel="noopener" href="https://blog.algomaster.io/p/design-a-chat-application-like-whatsapp">https://blog.algomaster.io/p/design...</a></p>
</blockquote>
<p>几乎每个人都使用<strong>聊天应用程序</strong>来发送消息和保持联系。</p>
<p>拥有超过<strong>25亿</strong> <strong>活跃用户</strong>，每天交换超过<strong>1000亿条消息</strong>，<strong>WhatsApp</strong>是世界上最受欢迎的消息应用程序。</p>
<p>但是建立这样一个可以实时连接全球数十亿人的平台需要什么？</p>
<p>在本文中，我们将深入探讨构建这种<strong>可扩展</strong> <strong>聊天应用程序</strong>的高级设计。</p>
<img src="https://iq7yw19tqs.feishu.cn/space/api/box/stream/download/asynccode/?code=ODRiZDQ0NDBjMzU1OWZjMTY3YWVmZTAzZGQ4ZDM1MmZfbHlCMWJjWnZEbTV1Q0h2U29MTnBsbEZ1Ukloc0pNYUNfVG9rZW46SEhwa2J2R21pb0k0NEp4V2lSNWNRWUtBbnFiXzE3Mzg5MTc2Nzk6MTczODkyMTI3OV9WNA" alt="img" style="zoom:25%;" />

<p>**<a target="_blank" rel="noopener" href="https://dub.sh/ZQz2PMk">多人游戏</a>**自动记录您的系统，从高级逻辑架构到各个组件、API、依赖项和环境。非常适合希望加快工作流程和整合技术资产的团队。</p>
<p><a target="_blank" rel="noopener" href="https://dub.sh/ZQz2PMk">开始使用</a></p>
<ul>
<li>支持<strong>用户之间1:1</strong> <strong>的实时消息传递</strong>。</li>
<li>显示用户的<strong>在线&#x2F;离线</strong>状态和<strong>上次看到时间</strong>。</li>
<li>显示<strong>消息送达状态</strong>（已发送、送达、已读）</li>
<li>允许用户共享<strong>图像</strong>、<strong>视频</strong>和<strong>音频剪辑</strong>。</li>
<li>支持最多100名成员的<strong>群组对话</strong>。</li>
<li>如果接收者离线，则为新消息发送<strong>推送通知</strong>。</li>
<li><strong>存储</strong>和<strong>检索</strong>每个用户的聊天记录。</li>
<li><strong>可扩展性</strong>：处理数百万并发用户。</li>
<li><strong>高可用性</strong>：确保最小的停机时间和对服务器故障的弹性。</li>
<li><strong>低延迟</strong>：以最小延迟实时传递消息。</li>
<li><strong>可靠性</strong>：确保消息不会丢失。</li>
</ul>
<p>让我们假设我们的聊天应用程序具有以下流量特征：</p>
<blockquote>
<p><strong>总用户</strong>：假设10亿注册用户。</p>
</blockquote>
<blockquote>
<p><strong>每日活跃用户（日活用户）</strong>：每天约有5亿用户积极使用该应用程序。</p>
</blockquote>
<blockquote>
<p><strong>峰值并发连接</strong>：大约5000万用户在高峰时间连接。</p>
</blockquote>
<p><strong>平均每天消息数</strong>：如果每个活跃用户平均每天发送10条消息，则每天会产生50亿条消息。</p>
<p>假设每条消息大约是1KB。</p>
<ul>
<li><strong>每日存储</strong>：1KB×50亿消息&#x3D;5TB</li>
<li><strong>年存储</strong>：365×5TB≤1.8PB（PB）</li>
</ul>
<p>1000万用户在高峰期同时连接。</p>
<ul>
<li><strong>每个连接的平均带宽</strong>：假设每个连接平均10KB&#x2F;s，我们总共需要100 GB&#x2F;s的带宽来支持高峰使用时的实时消息传递。</li>
</ul>
<p>这些<strong>聊天服务器</strong>管理大量的并发连接，促进实时通信，并确保以最小的延迟在用户之间有效地传递消息。</p>
<p>为了支持无缝的双向消息传递，像**<a target="_blank" rel="noopener" href="https://blog.algomaster.io/p/websockets">WebSockets</a>**这样的协议——为客户端和服务器之间的本地双向通信而设计——是理想的。（我们稍后会更详细地研究这个问题。）</p>
<p>该<strong>负载均衡器</strong>可在聊天服务器和面向用户的服务（如媒体服务）的多个实例之间有效地分配来自用户的传入流量。</p>
<p>以下是通过负载均衡器在用户和聊天服务器之间建立连接的方式：</p>
<ul>
<li><strong>初始连接</strong>：客户端发起一个HTTP（S）请求来建立WebSocket连接。该请求通过负载均衡器，负载均衡器根据用户位置和使用的负载均衡算法（例如循环、最少连接）等因素将其路由到适当的聊天服务器。</li>
<li><strong>连接升级</strong>：一旦请求到达选定的服务器，连接将从HTTP升级到WebSocket，通过负载均衡器在客户端和选定的聊天服务器之间建立持久的双向WebSocket链接。</li>
<li><strong>会话持久性</strong>：为了确保客户端保持连接到同一聊天服务器，负载均衡器使用<strong>粘性</strong>会话。这可以通过<strong>IP散列</strong>来实现，其中负载均衡器根据用户IP地址的散列一致地将用户路由到同一服务器。</li>
</ul>
<p>另一种方法是使用服务发现，它使用户能够直接连接到聊天服务器。</p>
<p>在这种情况下，用户首先连接到服务发现层以识别他们应该连接到的聊天服务器，然后直接与该服务器建立WebSocket连接。</p>
<p>“<strong>用户连接缓存</strong>”是一个快速的内存缓存（例如Redis），用于存储每个用户的活动连接详细信息，例如他们连接到的聊天服务器和他们的<code>last_active</code>时间戳。</p>
<p><img src="https://iq7yw19tqs.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTljNDFhN2E3ZmRjYTY0Y2Y3YWNhOTZhODIwMGYzOGRfQnJSTXBVNTdlOHY0RXJ1WTZHaVJXd2R5c2h5QzZGb3NfVG9rZW46UllzM2J5VEFTb3VvN1F4dGNEMGNuUURobk5lXzE3Mzg5MTc2Nzk6MTczODkyMTI3OV9WNA" alt="img"></p>
<p>客户端定期向其连接的服务器发送心跳信号，每次心跳都会更新缓存中用户的<code>last_active</code>时间戳。</p>
<p>此设置可有效支持<code>在线/离线</code>状态和<code>上次看到</code>的功能。</p>
<p>如果当前时间与时间戳之间的差异<code>last_active</code>在定义的阈值（例如3秒）内，则用户显示为在线；否则，他们被标记为离线。</p>
<p> **<a target="_blank" rel="noopener" href="https://blog.algomaster.io/p/design-a-scalable-notification-service">通知服务 </a>**负责 向用户发送实时通知，尤其是当用户离线或未主动使用应用程序时。</p>
<p>当用户离线时，聊天服务器会将消息转发给通知服务。</p>
<p>为了提高效率，聊天服务器可以将该消息发送到消息队列，而不是直接与通知服务交互并等待响应。</p>
<p>通知服务与外部推送通知提供商（如<strong>Firebase云消息（FCM）<strong>和</strong>Apple推送通知服务（APNS））集成</strong>，以推送通知的形式向离线用户传递消息。</p>
<p>消息**<a target="_blank" rel="noopener" href="https://blog.algomaster.io/p/message-queues">队列</a>**是一个分布式的、高吞吐量的队列（例如Kafka、RabbitMQ）。</p>
<p>通过充当中介，消息队列将消息存储与聊天服务器上的实时消息处理分离，从而减少延迟并增强应用程序的可扩展性。</p>
<p> <strong>消息存储服务</strong> 负责 聊天消息的可靠存储、快速检索和高效归档。</p>
<p>它使用来自 <strong>消息队列的传入消息</strong> 并将其保存在 <strong>消息数据库中，</strong> 以实现高效的存储和检索。</p>
<p> <strong>消息数据库</strong> 以 可靠、高效的方式存储所有聊天消息，确保用户可以访问过去的消息。</p>
<p>该数据库旨在实现<strong>高写入</strong>吞吐量和高效检索（例如<strong>Cassandra</strong>），以处理实时聊天应用程序中的大量消息。</p>
<p>群组 <strong>服务</strong> 负责处理所有与群组相关的功能，包括创建群组、更新群组详细信息和管理群组成员资格。</p>
<p>当需要将消息传递给群组对话时，聊天服务器会查询群组服务以检索当前群组成员列表。</p>
<p>群组<strong>数据库</strong>存储和检索与群聊相关的所有数据，包括群组ID、成员列表、管理员角色和群组设置。</p>
<p>媒体 <strong>服务</strong> 负责处理多媒体内容（例如图像、视频和音频文件）的上传和管理。</p>
<p>它将媒体文件安全地存储在 Blob 存储系统中，同时将元数据（例如文件类型、大小和上传时间戳）保存在单独的数据库中，以便于访问和组织。</p>
<p>通过从主聊天服务器卸载媒体存储，媒体服务可以减少聊天服务器上的带宽使用量并提高整体应用程序性能。</p>
<p>Blob<strong>Store</strong>是聊天应用程序多媒体内容的存储后端，包括图像、视频、音频文件和文档。</p>
<p>它旨在处理大量媒体内容，同时确保快速、安全和可靠的访问。</p>
<p>媒体商店通常利用基于云的对象存储解决方案（例如Amazon S3、Google Cloud Storage或Azure Blob Storage），提供高耐用性、可扩展性和成本效益。</p>
<p> **为了减少上传或下载多媒体内容时的延迟，文件通过内容分发网络（CDN）**分发到地理位置更靠近用户的位置。</p>
<p>当用户共享多媒体文件时，客户端应用程序会将其直接上传到 CDN，并将其存储在靠近收件人的位置。</p>
<p>客户端并不发送文件本身，而是将文件的URL作为消息的一部分发送到聊天服务器，从而允许其他用户从最近的CDN位置快速高效地下载和访问内容。</p>
<p>一旦文件上传到CDN，媒体服务就会检索它们并将其存储在Blob存储中以供长期存储。</p>
<p>这种方法减少了聊天服务器的负载，最大限度地减少了延迟，并显著提高了用户的媒体传输速度。</p>
<p><a target="_blank" rel="noopener" href="https://blog.algomaster.io/p/design-a-chat-application-like-whatsapp?utm_source=substack&utm_medium=email&utm_content=share&action=share&token=eyJ1c2VyX2lkIjozMTIyMDM5NTksInBvc3RfaWQiOjE0NzU0ODUwMiwiaWF0IjoxNzM3NjIwNDQ2LCJleHAiOjE3NDAyMTI0NDYsImlzcyI6InB1Yi0yMjAyMjY4Iiwic3ViIjoicG9zdC1yZWFjdGlvbiJ9.NtYkYOZCJlIVDvora4oa4KKS3yDf55aFMUfcnNFQmj0">分享</a></p>
<p>对于聊天应用程序，数据库需要处理 <strong>用户</strong> 、 <strong>消息</strong> 和 <strong>群组等核心实体</strong> 。</p>
<p>以下是可以支持可扩展且高效的聊天应用程序的数据库设计的细目。</p>
<p><img src="https://iq7yw19tqs.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGIyYjU3MDk3NTQ3MDMwY2MzYWRkNzcwZWFlMzQ3M2ZfRnZZTHFCclhzOUo3VFVkbU92OHpKSURWOEtDT0lwSHZfVG9rZW46SVpJN2JEbnNub1pWYUh4aTdhSWNrMWtpbndnXzE3Mzg5MTc2Nzk6MTczODkyMTI3OV9WNA" alt="img"></p>
<p>为了存储用户、群组和对话数据，我们可以使用PostgreSQL之类的SQL数据库。</p>
<p>对于消息数据，由于写入吞吐量高，最好使用像Cassandra这样的非关系型数据库数据库。</p>
<p>对于媒体文件，像AWSS3这样的对象存储提供了可扩展且安全的存储。</p>
<p>为了理解为什么 WebSocket 是实时消息传递的理想选择，让我们来研究一下其他潜在的解决方案及其局限性：</p>
<p>在轮询中，客户端定期向服务器发送 HTTP 请求以检查是否有新消息。</p>
<p><strong>缺点</strong> ：轮询会占用大量资源，尤其是在轮询频率较高的情况下。由于服务器大多数时候都会回复“没有新消息”，因此这种方法会增加大量开销并浪费服务器资源。</p>
<p>在长轮询中，客户端会保持与服务器的开放连接，直到有新消息可用或发生超时。当服务器有新数据时，它会做出响应，而客户端会立即重新建立连接，从而重新启动该过程。</p>
<p>虽然这减少了标准轮询中重复请求的需要，但长轮询有几个限制：</p>
<ul>
<li><strong>连接开销</strong> ：每次消息交换都需要重新建立连接，这会产生很大的开销并给服务器和网络资源带来沉重的负担。</li>
<li><strong>资源消耗</strong> ：服务器必须维持许多开放的连接，即使没有主动的数据交换也会消耗内存和容量。</li>
<li><strong>延迟问题</strong> ：如果超时时间较长，消息可能会延迟。如果超时时间较短，频繁重置会增加与标准轮询相同的开销。</li>
</ul>
<p>总体而言，长轮询的连接和资源需求使其不太适合实时聊天应用程序。</p>
<p>另一方面，WebSocket消除了重复的HTTP握手、标头和响应的需要，从而减少了开销并提高了性能。</p>
<p>客户端和服务器建立一次连接，并且该连接在整个聊天会话期间保持打开，从而实现无缝数据传输。</p>
<p>这种持久连接使 WebSocket 成为实时通信的理想选择，客户端和服务器都需要频繁、及时地交换数据。</p>
<p>当用户打开聊天应用程序时，它会与其中一个聊天服务器发起WebSocket连接，从而实现客户端和服务器之间的实时通信，而无需重复HTTP请求。</p>
<p>一旦连接，当用户A向用户B发送消息时，该消息将通过用户A的WebSocket连接到管理该连接的服务器A。</p>
<p>然后，服务器A查找**用户连接缓存，**以确定用户B是否在线，如果在线，则确定哪个服务器当先拥护有用户B的连接。</p>
<ul>
<li><strong>如果用户B在线</strong>：服务器A将消息转发到服务器B，服务器B通过其打开的WebSocket连接将消息传递给用户B。</li>
<li><strong>如果用户B离线</strong>：服务器A将消息发送到<strong>通知服务</strong>，通知服务触发推送通知，通知用户B有新消息。</li>
</ul>
<p>WebSockets 支持消息的实时状态更新（例如“消息已发送”、“消息已送达”、“消息已读”），为用户提供消息状态的即时反馈。</p>
<p>当用户A发送消息时，该消息会通过其WebSocket连接传输到处理其连接的服务器（服务器A）。</p>
<ol>
<li>服务器A收到消息，将其推送到消息队列进行存储，并向用户A发回确认。</li>
<li>收到此确认后，用户 A 的应用程序将消息状态更新为“已发送”。</li>
</ol>
<p>如果用户A在尝试发送消息时处于离线状态，则消息将不会发送，直到他们重新上线.消息在用户A的设备上保持待处理状态，直到重新连接并成功将消息发送到服务器A。</p>
<p>一旦用户B收到消息，它就会向服务器B发送确认。</p>
<ul>
<li>服务器B向服务器A发送交付确认。</li>
<li>服务器A将消息状态“已交付”发送到消息队列以进行永久存储，然后将此更新中继到用户A的应用程序，该应用程序将消息反映为“已交付”。</li>
</ul>
<p>如果用户B离线，服务器A将不会收到来自服务器B的传递确认，因此消息对用户A保持“已发送”状态，直到用户B重新连接。</p>
<p>当用户B上线时，客户端应用程序将更新发送到服务器B，此时它向服务器A发送“已交付”确认。然后更新用户A的应用程序以反映“已交付”状态。</p>
<p>当用户B打开聊天窗口并查看消息时，他们的应用程序会向服务器B发送“已读”确认。</p>
<ol>
<li><strong>服务器B</strong>在消息队列中记录此事件，并将“读取”状态转发给服务器A。</li>
<li><strong>服务器A</strong>将此更新推送到用户A的设备，允许用户A的应用将消息显示为“已读”</li>
</ol>
<p>如果用户B离线，他们无法查看消息，因此不会触发“已读”状态。当用户B重新连接并打开聊天时，他们的应用程序将向服务器B发送“已读”确认。</p>
<p>服务器B在消息队列中记录“已读”状态并将其转发给服务器A。然后，用户A的应用程序接收此更新，将消息标记为“已读”。</p>
<ol>
<li>当用户A在群聊中发送消息时，消息通过用户A的WebSocket连接传输到管理该连接的服务器（服务器A）。</li>
<li><strong>服务器A</strong>查询<strong>组服务</strong>以检索组中所有活动成员的列表。</li>
<li><strong>服务器A</strong>检查<strong>用户连接缓存</strong>以确定哪些组成员当前在线以及它们连接到的特定服务器。</li>
<li><strong>对于每个在线会员</strong>：<ol>
<li>如果一个成员连接到<strong>服务器A</strong>，它将直接通过现有的WebSocket连接传递消息。</li>
<li>如果成员连接到不同的服务器（例如，<strong>服务器B</strong>），<strong>服务器A</strong>将消息转发到<strong>服务器B</strong>，然后通过他们的WebSocket连接将消息传递给用户。</li>
</ol>
</li>
<li>对于脱机组成员，<strong>服务器A</strong>将消息发送到<strong>通知服务</strong>。通知服务为每个脱机组成员触发推送通知，提醒他们新消息。</li>
</ol>
<p>在群聊中，发送的每条消息都必须分发给（或“分发给”）每个群成员。</p>
<p>随着组规模的增加，扇出工作负载也会增加。例如，在一个由500名成员组成的组中，每条消息都需要500个单独的消息传递，这可能会很快使服务器不堪重负。</p>
<p>这就是为什么大多数聊天应用程序都限制了一个群组可以拥有的成员数量（WhatsApp目前有1024个）。</p>
<p>为了确保所有组成员都可以访问消息历史记录，<strong>服务器A</strong>将消息推送到<strong>消息队列</strong>进行存储。</p>
<p>消息<strong>存储服务</strong>使用队列中的消息并将其存储在<strong>消息DB</strong>中，供组成员稍后检索。</p>
<ul>
<li>当每个联机组成员收到消息时，他们各自的服务器向<strong>服务器A</strong>发送传递确认（或者如果需要，直接更新<strong>消息DB</strong>中的状态）。</li>
<li>一旦用户打开并查看消息，已读确认类似地传播回<strong>服务器A</strong>并存储以供将来参考，允许用户A查看哪些组成员已收到并已读消息。</li>
</ul>
<p>为了有效地检索最近的消息，我们可以使用<strong>基于时间的消息ID。</strong></p>
<p>基于时间的消息ID通常将时间戳与每个消息的唯一标识符相结合。</p>
<p>这允许我们按时间戳对消息进行排序，检索特定时间范围内的消息，并支持分页（“加载更多”），您可以在特定时间戳之前或之后检索消息，而无需重新排序数据集。</p>
<p>一种常见的格式可能包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Timestamp in milliseconds][Unique Sequence/Random Component]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间戳（以毫秒为单位）</strong>：ID的第一部分是创建消息的时间戳。这允许消息按创建时间按时间顺序排序。</li>
<li><strong>唯一序列或随机化组件</strong>：附加唯一组件（如随机或增量序列）可确保每个消息ID都是唯一的，即使在同一毫秒内发送多个消息也是如此。</li>
</ul>
<p>例如，在<code>2024-11-0512:34:56.789</code>发送的序列为<code>001</code>的消息可能具有ID：<code>20241105123456789001</code>。</p>
<p>如天服务器发生故障，连接到该服务器的所有客户端都将失去连接。</p>
<p>为了恢复，客户端会自动尝试重新连接，这一次与不同的可用服务器建立新连接。</p>
<p>负载均衡器通过定期健康检查持续监控每个聊天服务器的健康状况。</p>
<p>如果服务器出现故障，负载均衡器会立即停止向其引导流量，确保新连接仅路由到健康的服务器。</p>
<p>为了支持水平扩容和高效的数据访问，我们可以跨不同的数据类型实现分片：</p>
<ol>
<li><strong>用户数据分片</strong>：基于<code>user_id</code>对用户数据进行分片。这将允许我们将用户记录分布在多个服务器上，并使我们能够随着用户群的增长而扩展。</li>
<li><strong>消息数据分区</strong>：基于<code>message_id</code>对消息进行分区，使用基于时间戳的<code>message_id</code>来实现高效的基于时间的搜索。这种结构允许快速访问最近的消息，并根据时间戳定位较旧的消息。</li>
</ol>
<p>对于大量消息和多媒体内容，优化存储成本至关重要。</p>
<p>这里有一些有效的策略：</p>
<ol>
<li><strong>压缩多媒体文件</strong>：压缩大文件（例如，图像，视频）可以减少存储需求并显着降低成本。</li>
<li><strong>存档旧消息</strong>：大多数用户只访问最近的消息，这些消息可以本地缓存在他们的设备上。旧消息可以移动到成本更低的冷存储（例如，Amazon Glacier），减少费用，同时仍然允许访问（如果需要）。</li>
<li><strong>去重文件</strong>：通过实现消重来避免存储相同文件的多个副本，当同一媒体在多个用户或组之间共享时，可以节省大量空间。</li>
<li><strong>高效元数据存储</strong>：将元数据（例如，文件类型、大小、时间戳）与媒体本身分开存储，以减少主存储的负载，并使搜索更快、更高效。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tomahawk2018.github.io/2025/02/07/%E8%AE%BE%E8%AE%A1%E5%83%8FWhatsApp%E8%BF%99%E6%A0%B7%E7%9A%84%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AE%BF%E8%B0%88/" data-id="cm6uj3e0k00049gvuhbe7axhe" data-title="设计像WhatsApp这样的聊天应用程序-系统设计访谈" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-用代码解释基本OOP概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/07/%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E5%9F%BA%E6%9C%ACOOP%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2025-02-07T08:33:23.000Z" itemprop="datePublished">2025-02-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B5%84%E6%96%99%E5%BA%93/">资料库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/07/%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E5%9F%BA%E6%9C%ACOOP%E6%A6%82%E5%BF%B5/">用代码解释基本OOP概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>🔗 原文链接： <a target="_blank" rel="noopener" href="https://blog.algomaster.io/p/basic-oop-concepts-explained-with-code">https://blog.algomaster.io/p/basic-...</a></p>
</blockquote>
<p><img src="https://iq7yw19tqs.feishu.cn/space/api/box/stream/download/asynccode/?code=NTIzYWZlYTAyMTE0NDdhZmZmODdlNzNmNTRmZjdkMDVfWGM2aXdId0tpemlVVDhQNThuVUlrMnJrcWZ2anI1Qk5fVG9rZW46TkNld2JOclBEb3ZRMEd4WEFoS2N0Z25XbmRkXzE3Mzg5MTcyNTc6MTczODkyMDg1N19WNA" alt="img"></p>
<p><strong>面向对象编程（OOP）是软件开发中的一个基本概念，它围绕类</strong>和<strong>对象</strong>的概念展开。   </p>
<p>学习<strong>OOP</strong>有助于我们创建高效、模块化、可维护的代码。</p>
<p>在本文中，我们将使用易于理解的<strong>代码示例探索核心OOP概念</strong>。 </p>
<blockquote>
<p>类是 <strong>定义</strong> 对象属性和行为的蓝图或模板。对象 <strong>是</strong> 使用类定义创建的类的实例。</p>
</blockquote>
<p> <strong>以下是Python中类</strong>定义的一个示例： </p>
<p><img src="https://iq7yw19tqs.feishu.cn/space/api/box/stream/download/asynccode/?code=MzFhZTNlOWU3ZDUwMTc5ZjdhYWUxNDliYWM5Y2M5YmNfZEs0Q3g4MW5aV2lNajIyalpOOUtIWHhBaUZFQ0w2S2dfVG9rZW46RnZ4a2JpRU5Hb2ZnVk54Y25DQ2NtUm1mbnlkXzE3Mzg5MTcyNTc6MTczODkyMDg1N19WNA" alt="img"></p>
<p>在这个例子中，<code>Car</code>类是定义汽车属性的蓝图。</p>
<p><img src="https://iq7yw19tqs.feishu.cn/space/api/box/stream/download/asynccode/?code=MzQ4YTdjM2Q2ZWYyMzQzODRlNWVmMGM0NTdiNDJmZGZfbnlSYnJkclVjdmQxRldIVldsSEhna1hCeXdRc1loNkhfVG9rZW46SEU1eWJPaGNTb0N1NUh4NE5SMWNrZHJLbjRjXzE3Mzg5MTcyNTc6MTczODkyMDg1N19WNA" alt="img"></p>
<p>我们创建两个<strong>对象</strong>，<code>toyota_car</code>和，<code>chevrolet_car</code>它们是类的实例<code>Car</code>.两辆汽车对象都可以<code>start_engine（）</code>使用它们自己的值来调用方法，作为<code>make</code>，<code>model</code>和<code>year</code>属性。</p>
<blockquote>
<p><strong>封装</strong> 是向外界隐藏对象的实现细节并仅通过公共方法公开必要的信息的概念。</p>
</blockquote>
<p>封装有助于保护对象的内部状态免受外部干扰和滥用。</p>
<p>在Python中，可以使用私有属性和方法实现封装，用双下划线<strong>前缀（</strong><code>__</code> <strong>）表示</strong>。</p>
<p><img src="https://iq7yw19tqs.feishu.cn/space/api/box/stream/download/asynccode/?code=MjY0NDZjMjA0ZjcwZjI5ZmVjMmY5OGUyOTM1ZTljZGVfam05MGFtNzZ3blRibXlOVEZRM0owN3dEeDZ4cUZMQkFfVG9rZW46TE1OcGJJTEVib1ZkTlZ4OHI4aGNpV0pYblZoXzE3Mzg5MTcyNTc6MTczODkyMDg1N19WNA" alt="img"></p>
<p>在此示例中，<code>__account_number</code>和<code>__balance</code>属性是私有的，这意味着它不能从类外部直接访问。我们通过<code>存款</code>、<code>取款</code>和<code>get_balance</code>方法与其交互。</p>
<p><a target="_blank" rel="noopener" href="https://blog.algomaster.io/p/basic-oop-concepts-explained-with-code?utm_source=substack&utm_medium=email&utm_content=share&action=share">分享</a></p>
<blockquote>
<p><strong>继承是一种允许一个类从另一个类（称为 超类</strong> 或 <strong>父类）</strong> 继承属性和方法的机制 。    </p>
</blockquote>
<p>继承的类称为 <strong>子类</strong> 或者 <strong>子类</strong> 。</p>
<p>子类继承了父类的所有字段和方法，也可以添加新的字段和方法，或者覆盖从父类继承的字段和方法。</p>
<p>继承促进 <strong>代码重用</strong> 并有助于创建 <strong>分层</strong> 结构。</p>
<p>假设我们有一个名为的父<code>车辆</code>类，其中有一个名为的方法<code>honk（）</code>。</p>
<p><img src="https://iq7yw19tqs.feishu.cn/space/api/box/stream/download/asynccode/?code=NzY2ZjAwM2EwODkwOWJiZWYyM2FjYzU4MTk3ZDkwZWRfMEV6aGRHYVpSZHdmQnk0a3Q1azBvd2wwVVRDNGtMeEhfVG9rZW46S0FEZmJNOHltb3Zkd0F4eEdjRmN4Szd0bm9lXzE3Mzg5MTcyNTc6MTczODkyMDg1N19WNA" alt="img"></p>
<p>该类从类中<code>Car</code>继承了<code>颜色</code>属性和方法，从而促进了代码重用。该类还添加了自己的属性和方法，例如和.<code>honk</code>  <code>车辆</code>  <code>汽车</code>  <code>速度</code>  <code>加速</code> </p>
<blockquote>
<p>多态性是指对象具有多种形式的能力。</p>
</blockquote>
<p>它使您能够编写可与多种类型的对象一起使用的通用代码，只要它们共享一个公共接口。</p>
<p>实现多态性的常见方式是 <strong>方法覆盖。</strong></p>
<p>方法覆盖是指子类提供其父类中已定义的方法的特定实现。</p>
<p>例如，假设我们有一个<code>Document</code>定义方法的接口<code>show（）</code>。</p>
<p><img src="https://iq7yw19tqs.feishu.cn/space/api/box/stream/download/asynccode/?code=YWI5MjA1ZjA2MjlmOTJkMTY4Y2UwOGIwNzAxNmQxNTNfMHZZdHgydm5HN1hKajFJenVuSUV1VWp2THdMYkhmR3dfVG9rZW46SDVKRGI5dDdvbzdHMTN4VTdHM2NkREZhbldlXzE3Mzg5MTcyNTc6MTczODkyMDg1N19WNA" alt="img"></p>
<p>每个子类（<code>Pdf</code>，<code>Word</code>）都以不同的方式<code>Document</code>实现<code>show</code>方法（方法覆盖），但接口保持一致，从而能够使用单个循环对两个类进行迭代。</p>
<blockquote>
<p>抽象是仅向外界展示必要的信息同时隐藏不必要的细节的概念。</p>
</blockquote>
<p>抽象有助于简化复杂系统并聚焦于基本特征。</p>
<p>在Python中，可以使用<strong>抽象基类（ABC）<strong>和</strong>抽象方法实现抽象</strong>。</p>
<p>假设我们有一个名为的抽象基类<code>Shape</code>.通过从类（抽象基类）<code>Shape</code>继承，该类被标记为抽象类.<code>ABC</code> </p>
<p>在类内部<code>形状</code>，我们定义一个<code>area（）</code>使用<code>@abstractMethod</code>装饰器调用的抽象方法。</p>
<p><img src="https://iq7yw19tqs.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWUxZGNhYzcyYTQ1MzYwYzRkMjFhYzNkM2MxNThjOWJfZ3RhYjZNclRJcWxkbU8yQ1hDdXVWblNObXpsbHRKbUFfVG9rZW46WkExMmJPVFVOb0JYeXZ4NDFESWNLTktDbnFCXzE3Mzg5MTcyNTc6MTczODkyMDg1N19WNA" alt="img"></p>
<p> <code>Rectangle</code>和类<code>Circle</code>都继承自<code>Shape</code>类。</p>
<p>它们提供<code>area（）</code>针对其形状的方法的实现.请注意，实现细节对外界是隐藏的，只暴露抽象类定义的接口。</p>
<p>这些是面向对象编程的基本原理。</p>
<p>通过应用这些概念，您可以编写更有条理、可重用和可维护的代码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tomahawk2018.github.io/2025/02/07/%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E5%9F%BA%E6%9C%ACOOP%E6%A6%82%E5%BF%B5/" data-id="cm6uikd2k0000s0vufx1hh830" data-title="用代码解释基本OOP概念" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-中美外交辞令解读" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/07/%E4%B8%AD%E7%BE%8E%E5%A4%96%E4%BA%A4%E8%BE%9E%E4%BB%A4%E8%A7%A3%E8%AF%BB/" class="article-date">
  <time class="dt-published" datetime="2025-02-07T08:21:05.000Z" itemprop="datePublished">2025-02-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B5%84%E6%96%99%E5%BA%93/">资料库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/07/%E4%B8%AD%E7%BE%8E%E5%A4%96%E4%BA%A4%E8%BE%9E%E4%BB%A4%E8%A7%A3%E8%AF%BB/">中美外交辞令解读</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="中国外交用语解读"><a href="#中国外交用语解读" class="headerlink" title="中国外交用语解读"></a>中国外交用语解读</h3><ol>
<li><strong>亲切友好的交谈</strong>：谈的不错，下一步签协议。</li>
<li><strong>坦率交谈</strong>：分歧很大，无法沟通。</li>
<li><strong>交换了意见</strong>：会谈各说各的，没有达成协议。</li>
<li><strong>充分交换了意见</strong>：双方无法达成协议，吵得厉害。</li>
<li><strong>增进了双方的了解</strong>：双方分歧很大。</li>
<li><strong>会谈是有益的</strong>：双方目标暂时相距甚远，能坐下来谈就很好。</li>
<li><strong>我们持保留态度</strong>：我们拒绝同意。</li>
<li><strong>尊重</strong>：不完全同意。</li>
<li><strong>赞赏</strong>：不尽同意。</li>
<li><strong>遗憾</strong>：不满。</li>
<li><strong>不愉快</strong>：激烈的冲突。</li>
<li><strong>表示极大的愤慨</strong>：现在我拿你没办法。</li>
<li><strong>严重关切</strong>：可能要干预，但也可能萎掉。</li>
<li><strong>不能置之不理</strong>：即将干涉。</li>
<li><strong>保留做出进一步反应的权利</strong>：我们将报复，具体手段视环境而定，也可能最终不报复了。</li>
<li><strong>我们将重新考虑这一问题的立场</strong>：我们已经改变了原来的（友好）政策。</li>
<li><strong>拭目以待</strong>：最后警告。</li>
<li><strong>请于<em>月</em>日前予以答复</strong>：<em>月</em>日后我们两国可能处于非和平状态。</li>
<li><strong>由此引起的后果将由*负责</strong>：可能的话我国将诉诸武力（这也可能是虚张声势的俗语）。</li>
<li><strong>这是我们万万不能容忍的</strong>：战争在即。</li>
<li><strong>这是不友好的行动</strong>：这是敌视我们的行动，可能引起战争的行动。</li>
<li><strong>是可忍孰不可忍</strong>：不打算忍了，要动手了。</li>
<li><strong>悬崖勒马</strong>：不要再逼了，想挨打么？</li>
<li><strong>勿谓言之不预也</strong>：废话不说了，准备棺材吧。</li>
</ol>
<h3 id="美国外交用语解读"><a href="#美国外交用语解读" class="headerlink" title="美国外交用语解读"></a>美国外交用语解读</h3><ol>
<li><strong>“这个问题问得好”</strong>：每一个答非所问的回答的开场白。</li>
<li><strong>“我们在评估目前的形势”</strong>：我们还什么都没做。</li>
<li><strong>“我会去了解这个事情的”</strong>：我可能不会去了解，但明天记者会还可以问这个问题。</li>
<li><strong>“实际形势瞬息万变”</strong>：如果我现在表达官方立场，有人可能不满我的措辞。</li>
<li><strong>“我们欢迎这种讨论”</strong>：在动用了联邦政府的资源掩盖问题后，我们将透露一下次要的、已公布的信息。</li>
<li><strong>“所有的选项都摆在桌面上”</strong>：用炸弹轰炸。</li>
<li><strong>“我们不能排除任何可能”</strong>：我们保留做任何事、一切事的权利。</li>
<li><strong>“我们的立场一直十分清楚”</strong>：我会重复笼统原则，不回答你的问题。</li>
<li><strong>“我们严重关切”</strong>：对一个美国盟友的最严厉谴责。</li>
<li><strong>“不可容忍”</strong>：可以容忍——显然，我们还在考虑这个问题。</li>
<li><strong>“某政策不针对任何国家”</strong>：某政策是针对中国或伊朗的。</li>
<li><strong>“我们正与某国密切协商”</strong>：我们正假装与别国协商，为的是推卸责任和负担。</li>
<li><strong>“建议你参照……”(版本1)</strong>：参照以前一位高官的评论，而评论内容实质上与你的提问无关。</li>
<li><strong>“建议你参照……”(版本2)</strong>：参照另一个机构的发言人，后者也不会回答你的问题。</li>
<li><strong>“我还没看到报道”</strong>：今早我们都看到、并讨论了该报道，但有关它的问题我不太好回答。</li>
<li><strong>“我想你过度解读了”</strong>：用于凡是与白宫政策相冲突的新闻。</li>
<li><strong>“我现在无权评论此事”</strong>：会有一名匿名“官员”适时地向你透露。</li>
<li><strong>“某某人可以畅所欲言”</strong>：某人仍然没有彻底了解我们的明确立场，通常认为，此类人有自己的“一套打算”。</li>
<li><strong>“对此事我现在没有任何信息提供给你”</strong>：这是一个让人特别不舒服的问题，我当然不会回答。</li>
<li><strong>“我不会预先判断结果”</strong>：推迟就某件即将发生的事件进行评论。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tomahawk2018.github.io/2025/02/07/%E4%B8%AD%E7%BE%8E%E5%A4%96%E4%BA%A4%E8%BE%9E%E4%BB%A4%E8%A7%A3%E8%AF%BB/" data-id="cm6ui60i20009bcvudfjyed0y" data-title="中美外交辞令解读" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%94%B6%E9%9B%86/" rel="tag">收集</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AC%A2%E8%BF%8E/">欢迎</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B5%84%E6%96%99%E5%BA%93/">资料库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E9%9B%86/" rel="tag">收集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AC%A2%E8%BF%8E/" rel="tag">欢迎</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E6%8A%80%E6%9C%AF/" style="font-size: 20px;">技术</a> <a href="/tags/%E6%94%B6%E9%9B%86/" style="font-size: 10px;">收集</a> <a href="/tags/%E6%AC%A2%E8%BF%8E/" style="font-size: 10px;">欢迎</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/07/%E6%AC%A2%E8%BF%8E%E6%96%87%E7%AB%A0/">欢迎文章</a>
          </li>
        
          <li>
            <a href="/2025/02/07/%E4%B8%BB%E9%A1%B5-%E5%AD%90%E5%A0%86%E6%A0%88/">主页|子堆栈</a>
          </li>
        
          <li>
            <a href="/2025/02/07/%E8%AE%BE%E8%AE%A1%E5%83%8FWhatsApp%E8%BF%99%E6%A0%B7%E7%9A%84%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AE%BF%E8%B0%88/">设计像WhatsApp这样的聊天应用程序-系统设计访谈</a>
          </li>
        
          <li>
            <a href="/2025/02/07/%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E5%9F%BA%E6%9C%ACOOP%E6%A6%82%E5%BF%B5/">用代码解释基本OOP概念</a>
          </li>
        
          <li>
            <a href="/2025/02/07/%E4%B8%AD%E7%BE%8E%E5%A4%96%E4%BA%A4%E8%BE%9E%E4%BB%A4%E8%A7%A3%E8%AF%BB/">中美外交辞令解读</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 武仙北冕座长城<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>